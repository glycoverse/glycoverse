---
title: "Case Study: Glycomics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: Glycomics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette walks you through a complete glycomics analysis using `glycoverse`.
We'll explore the full spectrum of glycomics data analysis,
from data loading and preprocessing to statistical analysis and visualization.
We'll also dive into advanced glycan structure analysis,
including motif quantification and derived trait analysis.
Ready to dive in? Let's go!

**Heads up:** `glycoverse` is built on `tidy` principles throughout.
If you're new to `tidyverse` data analysis,
we highly recommend checking out Hadley Wickham's excellent [R for Data Science](https://r4ds.hadley.nz).
Trust us, it's worth the investment!

Quick readiness check:

- What's a `tibble`?
- How do you filter rows in a `tibble`?
- What's the modern alternative to `for` loops?
- What's the `%>%` operator? Do we still need it?
- What makes data "tidy"?

## Loading the Packages

Just like `tidyverse`, `glycoverse` is a meta-package that loads
a collection of specialized packages all at once.

```{r}
library(glycoverse)
```

We'll also need the `tidyverse` packages for this analysis.

```{r}
library(tidyverse)
```

## Reading the Data

Data import is typically your first step in any analysis.
For this tutorial, we'll use the `real_experiment2` dataset that comes with `glyexp`.
This is a real-world N-glycomics dataset from 144 patients across four liver conditions:
healthy controls (H), hepatitis (M), cirrhosis (Y), and hepatocellular carcinoma (C).

```{r}
real_experiment2
```

For your own glycomics projects, you can create an `experiment()` object manually.
See [this document](https://glycoverse.github.io/glyexp/articles/glyexp.html#building-your-own-data-empire) for more details.

The `real_experiment2` object is an `experiment()` object.
If you've worked with `SummarizedExperiment` from Bioconductor,
think of `experiment()` as its tidy cousin.
Essentially, it's a smart data container that manages three key components:

- **Expression matrix**: quantitative data with samples as columns and variables as rows
- **Sample information**: a tibble with sample metadata (group, batch, demographics, etc.)
- **Variable information**: a tibble with feature metadata (glycan compositions, glycan structures, etc.)

You can get these data components by using `get_expr_mat()`, `get_sample_info()`, and `get_var_info()`.

```{r}
get_expr_mat(real_experiment2)[1:5, 1:5]
```

```{r}
get_sample_info(real_experiment2)
```

```{r}
get_var_info(real_experiment2)
```

What makes `experiment()` objects so powerful?

1. **Universal compatibility**: All `glycoverse` functions speak the same language.
   They automatically know where to find what they need in an `experiment()` object,
   which eliminates the biggest headache in data analysis:
   constantly reformatting data to meet different function requirements.
   
2. **Synchronized operations**: You can use familiar `dplyr`-style functions
   to filter, select, and modify your data, and everything stays in sync automatically.
   No more worrying about mismatched sample names or lost metadata!

We'll see these benefits in action throughout this tutorial.
For a deeper dive into `experiment()` objects, check out [Get Started with glyexp](https://glycoverse.github.io/glyexp/articles/glyexp.html).

## Data Preprocessing

Raw quantification data needs preprocessing before analysis—that's just a fact of life in omics.
Typical steps include normalization, missing value imputation, and batch effect correction.
Rather than making you implement these tedious steps manually, `glyclean` provides a comprehensive preprocessing pipeline.
Just call `auto_clean()` on your `experiment()` object and you're good to go.

```{r}
clean_exp <- auto_clean(real_experiment2)
```

Your data is now analysis-ready!

Want to customize the preprocessing steps?
See [Get Started with glyclean](https://glycoverse.github.io/glyclean/articles/glyclean.html) for the full toolkit.


## Statistical Analysis and Visualization

Time for the fun part—statistical analysis and visualization!
We'll use `glystats` for the number crunching
and `glyvis` to make sense of the results visually.

Let's kick off with PCA to get a bird's-eye view of our data structure.

```{r}
#| fig-width: 4
#| fig-height: 4
plot_pca(clean_exp)  # from `glyvis`
```

`glyvis` isn't designed for publication-ready figures,
but it's perfect for quick exploratory visualization.
Behind the scenes, `plot_pca()` calls `gly_pca()` from `glystats`
and renders the results.

You can also break this down into separate steps:

```{r}
#| fig-width: 4
#| fig-height: 4
pca_res <- gly_pca(clean_exp)  # from `glystats`
autoplot(pca_res)  # from `glyvis`
```

We actually recommend the two-step approach,
since it gives you more flexibility with the results.
You can create custom `ggplot2` visualizations for publications
or extract the underlying data when reviewers ask for it.

`glystats` covers virtually all standard omics analyses.
All functions follow the same naming pattern: `gly_xxx()`—think `gly_anova()`, `gly_ttest()`, `gly_roc()`, `gly_cox()`, `gly_wgcna()`, and so on.
They all take an `experiment()` object as their first argument.

The return format is consistent across all functions—a list with two components:

- **`tidy_result`**: cleaned-up tibbles in tidy format.
  We've done the heavy lifting of organizing messy statistical output for you.
- **`raw_result`**: the original statistical objects.
  These are available when you need to dig deeper or perform advanced analyses.

Let's peek inside the `pca_res` object we just created:

```{r}
str(pca_res, max.level = 2)
```

As you can see, `pca_res$tidy_result` contains three tidy tibbles,
while `pca_res$raw_result` holds the original `prcomp` object from `stats::prcomp()`.
Check `?gly_pca` for the complete breakdown.

Here's what the `samples` tibble looks like:

```{r}
pca_res$tidy_result$samples
```

Notice the "group" column? That's `glystats` being helpful—
it automatically pulls relevant metadata from your `experiment()` object
and includes it in the results wherever it makes sense.

Back to that `autoplot()` magic we saw earlier.
It automatically recognizes different `glystats` result types and plots accordingly—
no manual specification needed.
The plots won't win any beauty contests, but they'll get your data insights across fast.

Now let's dive into differential expression analysis using the tried-and-true `limma` package.

```{r}
limma_res <- gly_limma(clean_exp)  # from `glystats`
limma_res$tidy_result
```

Excellent! Now let's identify significantly differentially expressed glycans between HCC and healthy samples.

```{r}
limma_res$tidy_result |>
  filter(p_adj < 0.05, contrast == "C_vs_H") |>
  select(glycan_composition, p_adj, log2fc)
```

For the full statistical arsenal, check out [Get Started with glystats](https://glycoverse.github.io/glystats/articles/glystats.html)
and [Get Started with glyvis](https://glycoverse.github.io/glyvis/articles/glyvis.html).

## Understanding Your Data Better

We want to subset the experiment to keep only "H" or "C" samples,
and only the significant glycans above.

```{r}
sig_vars <- limma_res$tidy_result |>
  filter(p_adj < 0.05, contrast == "C_vs_H") |>
  pull(variable)

sub_exp <- clean_exp |>
  filter_var(variable %in% sig_vars) |>
  filter_obs(group %in% c("H", "C"))

sub_exp
```

That last code chunk showcased some powerful `glyexp` features.
Let's take a moment to understand what's really happening under the hood.


First, what exactly are those `sig_vars`?
At first glance, they look pretty cryptic:

```{r}
sig_vars[1:5]
```

Let's revisit the variable information tibble:

```{r}
get_var_info(clean_exp)[1:5, ]
```

See that first "variable" column?
That's the index column that keeps everything synchronized.
It links the variable information tibble to the expression matrix.
Take a look at the expression matrix row names:

```{r}
get_expr_mat(clean_exp)[1:5, 1:5]
```

Notice how the row names match the "variable" column exactly, in the same order?
The same principle applies to samples—the "sample" column in sample info
matches the expression matrix column names.
This is how `experiment()` keeps all three data components perfectly synchronized.

![](experiment.png)

Of course, synchronization only matters when you're actually manipulating data.
`glyexp` provides a full suite of `dplyr`-style functions for data manipulation.
They work just like regular `dplyr` functions, but with helpful suffixes:
`xxx_obs()` functions operate on samples (observations),
and `xxx_var()` functions work with variables (features).

For instance, let's filter to just the healthy samples using `filter_obs()`:

```{r}
# Filter the data
exp_h <- clean_exp |>
  filter_obs(group == "H")
```

The syntax should feel familiar if you know `dplyr::filter()`.
The magic happens behind the scenes—the expression matrix updates automatically.
Let's verify the filtering worked by checking the dimensions:

```{r}
# Before filtering
cli::cli_text("Number of rows in sample information tibble: {nrow(get_sample_info(clean_exp))}")
cli::cli_text("Number of rows in variable information tibble: {nrow(get_var_info(clean_exp))}")
cli::cli_text("Dimensions of expression matrix: {ncol(get_expr_mat(clean_exp))} x {nrow(get_expr_mat(clean_exp))}")

# After filtering
cli::cli_text("Number of rows in sample information tibble: {nrow(get_sample_info(exp_h))}")
cli::cli_text("Number of rows in variable information tibble: {nrow(get_var_info(exp_h))}")
cli::cli_text("Dimensions of expression matrix: {ncol(get_expr_mat(exp_h))} x {nrow(get_expr_mat(exp_h))}")
```

In essence, `filter_obs()` applies `dplyr::filter()` to the sample information
and automatically updates the expression matrix to match.
`filter_var()` does the same for variables.
For the complete catalog of `dplyr`-style functions,
check out [this vignette](https://glycoverse.github.io/glyexp/articles/dplyr-style-functions.html).

Now that code snippet should make perfect sense:

```R
sig_vars <- limma_res$tidy_result |>
  filter(p_adj < 0.05, contrast == "C_vs_H") |>
  pull(variable)

sub_exp <- clean_exp |>
  filter_var(variable %in% sig_vars) |>
  filter_obs(group %in% c("H", "C"))
```

## Advanced Motif Analysis

Up to now, we've covered standard glycomics workflows.
While `glycoverse` certainly streamlines these analyses,
it truly shines when it comes to advanced glycan structure analysis.

Before diving into motifs, let's get acquainted with `glyrepr::glycan_structure()` vectors.

```{r}
clean_exp$var_info[["glycan_structure"]]
```

Just like `integer()` and `character()`, `glycan_structure()` is a specialized vector type.
Some software (like pGlyco3 and StrucGP) outputs structural information as text strings.
When you import this data using `glyread`, the `glyparse` package automatically
converts these strings into proper `glycan_structure()` vectors
and stores them in the variable information tibble.
Note that not all software provides structural data—some only give compositions.

For glycomics data, this information is hard to come by automatically.
You can do it manually by parsing the glycan structure strings using `glyparse`
and using `left_join_var()` to join the parsed structures to the variable information tibble.

Fortunately, our example dataset includes structural information,
opening up a world of advanced analytical possibilities.
Let's explore motif analysis.

**Quick note:** The printed structures use IUPAC-condensed notation,
which we'll also use for defining motifs below.
Don't worry if it looks intimidating—we'll include visual diagrams to help.
That said, if you're planning to do serious structural analysis,
learning IUPAC-condensed notation is worth the investment.
Check out [this guide](https://glycoverse.github.io/glyrepr/articles/iupac.html) to get started—it's easier than it looks!

Human serum N-glycans can have three types of branch terminals (ignoring a1-3 Fuc):

1. A Sialyl-LacNAc motif
2. A LacNAc motif without sialic acids
3. Only a GlcNAc without further elongation

![](branch_motifs.png)

Here's how we express these motifs in IUPAC-condensed notation:

```{r}
motifs <- c(
  motif1 = "Neu5Ac(??-?)Gal(??-?)GlcNAc(??-",
  motif2 = "Gal(??-?)GlcNAc(??-",
  motif3 = "GlcNAc(??-"
)
```

The "??-?" represents unknown linkages—a common limitation in mass spectrometry data.

Here's our research question: **Which branching motif show differential expression across conditions?**
Without `glycoverse`, this would be a nightmare to tackle manually.
Take a moment to imagine the pain of doing this by hand!

Now, the `glycoverse` solution:

```{r}
motif_anova_res <- clean_exp |>
  quantify_motifs(motifs, alignments = "terminal") |>  # quantify these motifs
  gly_anova()  # and perform ANOVA

motif_anova_res$tidy_result$main_test
```

`quantify_motifs()` transforms your data into a new `experiment()` object.
Instead of quantification of glycans, you now have motif abundances across samples.
Since it's still an `experiment()` object, all `glystats` functions work seamlessly—including `gly_anova()`.

Now we can answer our question using standard `tidyverse` operations,
since `motif_anova_res$tidy_result$main_test` is just a regular tibble:

```{r}
motif_anova_res$tidy_result$main_test |>
  filter(p_adj < 0.05)
```

Here's another common question:
**Which of the three branching motifs appears the most in all glycans?**

For this analysis, we don't need motif quantification—we just need to know
which glycans have these motifs.
`glymotif::add_motifs_lgl()` is perfect for this.

```{r}
clean_exp |>
  add_motifs_lgl(motifs, alignments = "terminal") |>
  get_var_info() |>
  select(glycan_composition, motif1, motif2, motif3) |>
  pivot_longer(-glycan_composition, names_to = "motif", values_to = "has_motif") |>
  summarise(n = sum(has_motif), .by = "motif")
```

`add_motifs_lgl()` adds three new TRUE/FALSE columns (`motif1`, `motif2`, `motif3`) to the variable information.

`glymotif` has much more to offer beyond these examples.
Dive deeper with [Get Started with glymotif](https://glycoverse.github.io/glymotif/articles/glymotif.html).

## Derived Trait Analysis

Let's wrap up with derived traits—a clever analytical approach
developed by the N-glycomics community for glycome characterization.
Classic examples include:

- High-mannose glycan proportion
- Core-fucosylation rate within complex glycans
- Average sialylation per galactose residue

`glydet` calculates derived traits in a flash.
Using it couldn't be simpler:

```{r}
trait_exp <- derive_traits(clean_exp)  # from `glydet`
trait_exp
```

That's it!
Just like `quantify_motifs()`, `derive_traits()` creates a new `experiment()` object,
but now with trait values per sample.

The variable information shows what we're working with:

```{r}
get_var_info(trait_exp)
```

The "trait" column lists all the derived traits we can analyze.

`glydet` comes with a comprehensive set of built-in traits:

- **`TM`**: Proportion of high-mannose glycans
- **`TH`**: Proportion of hybrid glycans  
- **`TC`**: Proportion of complex glycans
- **`MM`**: Average number of mannoses within high-mannose glycans
- **`CA2`**: Proportion of bi-antennary glycans within complex glycans
- **`CA3`**: Proportion of tri-antennary glycans within complex glycans
- **`CA4`**: Proportion of tetra-antennary glycans within complex glycans
- **`TF`**: Proportion of fucosylated glycans
- **`TFc`**: Proportion of core-fucosylated glycans
- **`TFa`**: Proportion of arm-fucosylated glycans
- **`TB`**: Proportion of glycans with bisecting GlcNAc
- **`SG`**: Average degree of sialylation per galactose
- **`GA`**: Average degree of galactosylation per antenna
- **`TS`**: Proportion of sialylated glycans

These represent the most widely used traits in glycomics literature.

Let's identify traits with significantly different values across conditions:

```{r}
trait_anova_res <- gly_anova(trait_exp)
trait_anova_res$tidy_result$main_test |>
  filter(p_adj < 0.05)
```

Once again, it's just that straightforward.

This just scratches the surface of `glydet`'s capabilities.
The real power lies in defining custom traits tailored to your research questions.
Explore the possibilities in [Get Started with glydet](https://glycoverse.github.io/glydet/articles/glydet.html).

## What's Next?

This vignette has given you a taste of `glycoverse` in action
through a real-world glycomics workflow.
But we've barely scratched the surface!
Now that you've got the basics down,
you're ready to unlock the full potential of each package.

Here's your roadmap to mastering each component:

- **[glyexp](https://glycoverse.github.io/glyexp/articles/glyexp.html)** — Master experiment objects and data manipulation
- **[glyread](https://glycoverse.github.io/glyread/articles/glyread.html)** — Import and organize glycomics data
- **[glyclean](https://glycoverse.github.io/glyclean/articles/glyclean.html)** — Build custom preprocessing pipelines  
- **[glystats](https://glycoverse.github.io/glystats/articles/glystats.html)** — Explore the full statistical toolkit
- **[glyvis](https://glycoverse.github.io/glyvis/articles/glyvis.html)** — Create stunning visualizations
- **[glymotif](https://glycoverse.github.io/glymotif/articles/glymotif.html)** — Define and analyze custom motifs
- **[glydet](https://glycoverse.github.io/glydet/articles/glydet.html)** — Create powerful derived traits
- **[glyenzy](https://glycoverse.github.io/glyenzy/articles/glyenzy.html)** — Explore enzyme-substrate relationships (we didn't cover this one, but it's fascinating!)
- **[glyrepr](https://glycoverse.github.io/glyrepr/articles/glyrepr.html)** — Master glycan structure representation
- **[glyparse](https://glycoverse.github.io/glyparse/articles/glyparse.html)** — Parse and convert structural formats

Happy glycan hunting! 🧬